# Project Memory - SagraFacile.NET Backend & Services

---
# Session Summaries (Newest First)

## (2025-06-26) - Integrated Profile Name Field in Windows Printer Service Settings
**Context:** Modified the Windows Printer Service to include the profile name as a field within the settings form instead of using a separate dialog window, improving the user experience by providing a unified interface.
**Accomplishments:**
*   **Windows Printer Service (`SagraFacile.WindowsPrinterService`):**
    *   **`SettingsForm.Designer.cs`:** Added a new "Nome Profilo" label and text field at the top of the form, repositioned all other controls accordingly, and increased the form height to accommodate the new field.
    *   **`SettingsForm.cs`:**
        *   Updated `PopulateControlsFromSettings()` to populate the profile name field from the current settings.
        *   Completely refactored `SaveProfileSettings()` to get the profile name from the text field instead of using `InputDialogForm`.
        *   Added validation for empty profile names with proper focus management.
        *   Added logic to handle profile renaming (automatically deletes old profile file when name changes).
        *   Updated `ButtonSave_Click()` to validate the profile name field before proceeding with save.
    *   **`ProfileSelectionForm.cs`:** Minor updates to pass the parent form as owner when opening SettingsForm dialogs for better modal behavior.
    *   **`Program.cs`:** Removed the unnecessary `InputDialogForm` registration from the dependency injection container since it's no longer used.
*   **Removed Dependencies:** The `InputDialogForm` is no longer used anywhere in the application, eliminating the separate dialog approach entirely.
**Key Decisions:**
*   Unified the profile management interface by integrating the profile name field directly into the main settings form.
*   Implemented proper validation and error handling for profile names, including duplicate name detection.
*   Added support for profile renaming with automatic cleanup of old profile files.
*   Maintained backward compatibility with existing profile files while improving the user experience.
**Outcome:** The Windows Printer Service now provides a streamlined, single-form interface for all profile settings, eliminating the need for separate dialogs and improving the overall user experience. Profile creation, editing, and renaming are now handled seamlessly within the unified settings interface.

## (2025-06-25) - Implemented Print Template Management & UI
**Context:** Implemented the full CRUD, default restoration, and preview functionality for print templates, including backend API, service logic, and frontend UI. Also addressed dialog overflow issues.
**Accomplishments:**
*   **Backend (.NET API):**
    *   **Print Templates:**
        *   Created `PrintTemplateService.cs` (`IPrintTemplateService`) for managing print templates (CRUD, restore defaults, generate preview).
        *   Created `PrintTemplatesController.cs` with API endpoints for all template operations (`GET`, `POST`, `PUT`, `DELETE`, `restore-defaults`, `preview`).
        *   Registered `IPrintTemplateService` in `Program.cs`.
        *   Embedded default HTML templates (`receipt.html`, `comanda.html`) as resources in the API assembly for the "Restore Defaults" feature.
    *   **DTOs:** Created `PrintTemplateDto`, `PrintTemplateUpsertDto`, `PreviewRequestDto` and `QueryParameters` (reused/adapted).
*   **Frontend (Next.js WebApp):**
    *   **Service:** Updated `printTemplateService.ts` with new API calls for `restoreDefaultTemplates` and `previewTemplate`.
    *   **Types:** Added `PreviewRequestDto` to `src/types/index.ts`.
    *   **UI Components:**
        *   Created `PrintTemplatePreviewDialog.tsx` to display PDF previews generated by the backend.
        *   Updated `src/app/app/org/[orgId]/admin/print-templates/page.tsx` to:
            *   Add a "Ripristina Default" (Restore Defaults) button.
            *   Add an "Anteprima" (Preview) action to the dropdown menu for HTML/PDF templates, which opens the `PrintTemplatePreviewDialog`.
    *   **UI Fixes:**
        *   Modified `PrintTemplatePreviewDialog.tsx` to use a flex column layout (`flex flex-col`) and `flex-1` on the content area, ensuring the PDF iframe scrolls and the footer buttons remain visible.
        *   Modified `PrintTemplateFormDialog.tsx` to use a flex column layout (`flex flex-col`) and `max-h-[90vh]` on the dialog content, with `overflow-y-auto flex-1` on the form fields container, ensuring the form scrolls and the footer buttons remain visible.
**Key Decisions:**
*   Centralized print template management in a dedicated backend service and controller.
*   Leveraged Puppeteer Sharp for robust HTML-to-PDF conversion on the backend for previews.
*   Implemented client-side dialogs with proper flexbox and overflow handling to prevent UI elements from becoming unreachable with long content.
**Outcome:** The system now provides a comprehensive and user-friendly interface for managing and previewing print templates, with improved UI stability for dialogs.

## (2025-06-23) - Enhanced Order Filtering and Optional Pagination
**Context:** Addressed feedback regarding order filtering on the waiter page and refined the pagination logic to be optional, allowing clients to fetch all items if pagination parameters are omitted.
**Accomplishments:**
*   **Backend (.NET API):**
    *   **Order Query Parameters:** Modified `SagraFacile.NET.API/DTOs/OrderQueryParameters.cs` to make `Page` and `PageSize` nullable (`int?`) to support optional pagination. Added `Statuses` property (`List<int>?`) to allow filtering orders by multiple statuses.
    *   **Order Service:** Updated `SagraFacile.NET.API/Services/OrderService.cs` (`GetOrdersAsync`) to conditionally apply pagination (Skip/Take) only if `Page` and `PageSize` are provided. Implemented filtering by the `Statuses` list if it's present in the query parameters. Adjusted `PaginatedResult` construction to correctly reflect total items when pagination is not applied.
**Key Decisions:**
*   Made pagination truly optional on the backend, allowing clients to retrieve all items by omitting `page` and `pageSize`.
*   Introduced status-based filtering for orders via the `Statuses` query parameter, enabling more granular control over fetched data.
**Outcome:** The backend API is now more flexible for order retrieval, supporting both paginated and full-list fetches, and allowing filtering by order statuses.

## (2025-06-20) - Resolved JWT Authentication Issues
**Context:** After a fresh server deployment, users could log in, but subsequent API calls failed with `SecurityTokenSignatureKeyNotFoundException` (401 Unauthorized). This indicated a mismatch in JWT configuration between token generation and validation.
**Accomplishments:**
*   **Standardized JWT Configuration:**
    *   Modified `SagraFacile.NET.API/Services/AccountService.cs` (token generation) to use `_configuration["JWT_SECRET"]`, `_configuration["JWT_ISSUER"]`, and `_configuration["JWT_AUDIENCE"]` directly. This aligns with how these values are set as top-level environment variables by `start.sh` and `docker-compose.yml`. Previously, it was attempting to read `Jwt:Key`, `Jwt:Issuer`, and `Jwt:Audience` from a nested configuration section.
    *   Modified `SagraFacile.NET.API/Program.cs` (token validation middleware) to also use `builder.Configuration["JWT_ISSUER"]` and `builder.Configuration["JWT_AUDIENCE"]` directly, instead of `builder.Configuration["Jwt:Issuer"]` and `builder.Configuration["Jwt:Audience"]`. The `JWT_SECRET` was already correctly configured here.
*   **Removed Serilog (Temporary Debugging Step):**
    *   To isolate issues during API startup, Serilog integration was temporarily commented out in `SagraFacile.NET.API/Program.cs`. Standard `Console.WriteLine` and `ILoggerFactory` were used for logging. This helped confirm that migrations and data seeding were running.
*   **Ensured Demo Data Seeding Variables:**
    *   Updated `docker-compose.yml` to explicitly pass `SAGRAFACILE_SEED_DEMO_DATA`, `INITIAL_ORGANIZATION_NAME`, `INITIAL_ADMIN_EMAIL`, `INITIAL_ADMIN_PASSWORD`, `SUPERADMIN_EMAIL`, `SUPERADMIN_PASSWORD`, and `DEMO_USER_PASSWORD` environment variables to the `api` service. This ensures the `InitialDataSeeder` behaves as expected based on the `.env` file generated by `start.sh`.
**Key Decisions:**
*   Consolidated JWT configuration to rely solely on top-level environment variables (`JWT_SECRET`, `JWT_ISSUER`, `JWT_AUDIENCE`) for both token generation and validation, ensuring consistency across the application and deployment scripts.
*   Temporarily removed Serilog to simplify debugging of API startup and data seeding processes.
**Outcome:** With these changes, JWT tokens should be generated and validated using the same consistent secret, issuer, and audience, resolving the 401 errors. The demo data seeding should also work correctly based on user choices during `start.sh` execution.
**Next Steps:**
*   User to test the deployment after these changes are applied.
*   (Future) Re-integrate Serilog once the core functionality is stable.

## (2025-06-16) - Enhanced Windows Printer Service Packaging and Autostart
**Context:** To improve the deployment and usability of the `SagraFacile.WindowsPrinterService`, it needed to be packaged as a self-contained executable and support profile-specific autostart functionality.
**Accomplishments:**
*   **Command-Line Profile Loading:**
    *   Modified `SagraFacile.WindowsPrinterService/Program.cs` to parse a `--profile-guid <GUID>` command-line argument.
    *   If a valid profile GUID is provided, the application now loads that specific profile directly, bypassing the `ProfileSelectionForm`.
*   **In-App Autostart Management:**
    *   Added `AutoStartEnabled` boolean property to `SagraFacile.WindowsPrinterService/Models/ProfileSettings.cs`.
    *   Updated `SagraFacile.WindowsPrinterService/SettingsForm.cs`:
        *   A new checkbox (`chkAutoStart`) allows users to enable/disable autostart for the current profile.
        *   The state of this checkbox is saved to the profile's JSON file.
        *   When saved, the form now calls `StartupManager.SetAutoStart()` to create or delete a shortcut in the Windows Startup folder.
    *   Created `SagraFacile.WindowsPrinterService/Utils/StartupManager.cs`:
        *   This new static class contains the `SetAutoStart(ProfileSettings profile, bool enable)` method.
        *   It uses `IWshRuntimeLibrary` (Windows Script Host Object Model) to create/delete `.lnk` shortcuts in `Environment.SpecialFolder.Startup`.
        *   The shortcut target includes the `--profile-guid` argument to launch the specific profile.
    *   Added the required COMReference for `IWshRuntimeLibrary` to `SagraFacile.WindowsPrinterService.csproj`.
*   **Self-Contained Executable Packaging (GitHub Actions):**
    *   Modified `.github/workflows/release-zip.yml`:
        *   Added `actions/setup-dotnet@v4` to ensure the correct .NET SDK version.
        *   Added a `dotnet publish` step to build `SagraFacile.WindowsPrinterService` as a self-contained, single-file executable (`SagraFacilePrinter.exe`) for `win-x64`.
        *   The `SagraFacilePrinter.exe` is now copied into the main `SagraFacile-${VERSION}-dist.zip`.
        *   `SagraFacilePrinter.exe` is also added as a separate asset to the GitHub Release.
        *   Updated the release notes body in the workflow to describe the new executable and its features.
*   **Documentation:**
    *   Updated `SagraFacile.NET/README.md` with a new section detailing the Windows Printer Service, its features (including autostart and command-line launch), packaging, and usage.
**Key Decisions:**
*   The Windows Printer Service will be distributed as a self-contained `.exe` for ease of use, requiring no separate .NET runtime installation by the user.
*   Autostart functionality is managed within the application on a per-profile basis, providing users with granular control.
*   The GitHub Actions release workflow now fully automates the build and packaging of this service alongside the main application.
**Outcome:** The Windows Printer Service is now easier to deploy and more user-friendly, with robust autostart capabilities for specific printer configurations.

## (2025-06-16) - Configured GitHub Actions for Release Packaging & Versioning Strategy
**Context:** To automate the creation of distributable ZIP packages for new releases and establish a clear versioning strategy for SagraFacile, making deployment easier.
**Accomplishments:**
*   **Versioning Strategy Adopted:** Semantic Versioning (`MAJOR.MINOR.PATCH`) will be used. Releases are triggered by Git tags prefixed with `v` (e.g., `v1.0.0`).
*   **GitHub Actions Workflow Created (`.github/workflows/release-zip.yml`):**
    *   A new workflow was implemented to automate the release packaging process.
    *   It triggers on pushes to tags matching the `v*.*.*` pattern.
    *   The workflow checks out the code, extracts the version from the Git tag, and then packages essential deployment files into a `SagraFacile-${VERSION}-dist.zip` archive.
    *   The packaged files include: `docker-compose.yml`, `Caddyfile`, `.env.example`, all `start/stop/update` scripts (`.sh` and `.bat`), `README.md`, `LICENSE.txt`, the newly created `sagrafacile_config.json.example`, and the entire `docs/` directory.
    *   Finally, the workflow uses the `softprops/action-gh-release` action to create a new GitHub Release, automatically attaching the generated ZIP file as a release asset.
*   **`sagrafacile_config.json.example` File Added:**
    *   A new example file, `sagrafacile_config.json.example`, was created in the project root. This file serves as a template for the `sagrafacile_config.json` that is generated by the interactive `start.sh` and `start.bat` scripts.
    *   This example file is now included in the distributable ZIP package created by the GitHub Action.
*   **Documentation Updated:**
    *   `Roadmap.md`: Relevant tasks in "Phase 7: Deployment & Monitoring" concerning the deployment ZIP package and automated GitHub Release packaging were marked as complete.
    *   `DEPLOYMENT_ARCHITECTURE.md`: Task 4.3 (Package for Distribution) was updated to note the inclusion of `sagrafacile_config.json.example` in the ZIP. Task 4.4 (Create GitHub Actions Workflow) was marked as implemented.
**Key Decisions:**
*   The release process is now highly automated, triggered by a simple `git tag` push.
*   The distributable ZIP contains all necessary configuration files and scripts for users to get started, excluding source code.
*   The `SagraFacile.WindowsPrinterService.Setup.exe` is noted as a separate artifact to be potentially added to releases manually or via a different build process.
**Outcome:** SagraFacile now has an automated mechanism for creating versioned release packages, significantly streamlining the distribution process and adhering to standard versioning practices.

## (2025-06-16) - Implemented Interactive Setup Scripts (`start.sh` & `start.bat`) & Updated Documentation
**Context:** To simplify the deployment process for SagraFacile and provide users with more control over the initial data seeding, interactive setup scripts were needed for both macOS/Linux (`start.sh`) and Windows (`start.bat`). This aligns with the goal of creating a downloadable ZIP package with guided setup.
**Accomplishments:**
*   **Modified `start.sh` for Interactive Setup (macOS/Linux):**
    *   The `start.sh` script was significantly updated to be interactive.
    *   It now checks for `sagrafacile_config.json`, prompts for essential settings (Domain, Cloudflare Token, DB credentials, JWT Secret), asks for data seeding preferences, saves choices to `sagrafacile_config.json`, and generates the `.env` file.
*   **Created Interactive `start.bat` (Windows):**
    *   A new `start.bat` script was created, mirroring the interactive functionality of `start.sh` for Windows users. This includes configuration checking, prompting, data seeding choices, saving to `sagrafacile_config.json`, and `.env` file generation.
*   **Backend Data Seeding (`InitialDataSeeder.cs`):**
    *   The existing `InitialDataSeeder` service seamlessly integrates with the configurations provided by both `start.sh` and `start.bat` via the generated `.env` file, as it was already designed to read the necessary environment variables.
*   **Documentation Updates:**
    *   `README.md`: Updated installation instructions to reflect the new interactive `start.sh` and `start.bat` processes and the role of `sagrafacile_config.json`.
    *   `DEPLOYMENT_ARCHITECTURE.md`: Updated to detail the interactive script flow for both platforms, the `sagrafacile_config.json` file, and its relation to the `.env` file and backend seeding.
    *   `Roadmap.md`: Marked relevant tasks under "Phase 7: Deployment & Monitoring" as complete for both `start.sh` and `start.bat`, and related backend seeding logic.
**Key Decisions:**
*   Both `start.sh` and `start.bat` provide a consistent interactive setup experience across platforms.
*   `sagrafacile_config.json` serves as the central, persistent store for user-defined configurations.
*   The `.env` file is treated as a dynamically generated artifact.
*   The backend's `InitialDataSeeder` required no changes, demonstrating good foresight in its initial design.
**Outcome:** The setup process for SagraFacile is now significantly more user-friendly and flexible on both macOS/Linux and Windows. Users can easily configure essential settings and control initial data seeding through an interactive command-line interface.
**Next Steps:**
*   Continue with other pending tasks in "Phase 7: Deployment & Monitoring" of the `Roadmap.md`, such as defining the deployment ZIP package contents and creating the GitHub Actions workflow for release packaging.

## (2025-06-16) - Refactored Data Seeding Logic
**Context:** The initial data seeding logic (System Defaults, Demo Data, Initial Org/Admin from env vars) was previously located directly in `Program.cs`. This made `Program.cs` verbose and mixed startup configuration with data initialization.
**Accomplishments:**
*   **Created `InitialDataSeeder.cs`:**
    *   A new service `SagraFacile.NET.API.Data.InitialDataSeeder` (and `IInitialDataSeeder` interface) was created.
    *   This class now encapsulates all data seeding logic, including:
        *   `SeedSystemDefaultsAsync()`: Seeds "System" organization, default roles ("SuperAdmin", "Admin", "AreaAdmin", "Cashier", "Waiter"), and a SuperAdmin user (credentials configurable via `SUPERADMIN_EMAIL`, `SUPERADMIN_PASSWORD`).
        *   `SeedSagraDiTencarolaDataAsync()`: Seeds the "Sagra di Tencarola" demo data (organization, users, areas, menu categories, and items). Demo user password configurable via `DEMO_USER_PASSWORD`.
        *   `SeedInitialOrganizationAndAdminAsync()`: Seeds an initial organization and an "Admin" user based on environment variables (`INITIAL_ORGANIZATION_NAME`, `INITIAL_ADMIN_EMAIL`, `INITIAL_ADMIN_PASSWORD`). This runs only if `SAGRAFACILE_SEED_DEMO_DATA` is `false` (or not set) and no other user-defined organizations (besides "System" or "Sagra di Tencarola") exist.
    *   The main `SeedAsync()` method orchestrates these based on the `SAGRAFACILE_SEED_DEMO_DATA` environment variable (defaults to `false`).
    *   The seeder uses `IServiceScopeFactory` to correctly resolve `DbContext`, `UserManager`, and `RoleManager` within its scope.
    *   Includes a `GenerateSlug` utility for creating slugs for seeded organizations.
*   **Updated `Program.cs`:**
    *   Registered the new service: `builder.Services.AddScoped<IInitialDataSeeder, InitialDataSeeder>();`.
    *   Removed all previous inline data seeding blocks.
    *   Added a static extension method `SeedDatabaseAsync(this IApplicationBuilder app)` in `InitialDataSeeder.cs` which calls `IInitialDataSeeder.SeedAsync()`.
    *   This extension method is called in `Program.cs` after database migrations are applied and before `app.Run()`, ensuring it only runs when not in the "Testing" environment.
    *   Corrected logger instantiation in the static extension method to use `ILoggerFactory`.
**Key Decisions:**
*   Centralized all initial data seeding logic into a dedicated service for better organization and maintainability.
*   Made the seeding process conditional based on the `SAGRAFACILE_SEED_DEMO_DATA` environment variable.
*   Ensured that seeding of an initial organization/admin from environment variables is skipped if other user-defined organizations already exist, preventing accidental overwrites or duplicate setups.
*   SuperAdmin and Demo User passwords can be configured via environment variables for better security in production-like setups.
**Outcome:** `Program.cs` is now cleaner. Data seeding is more modular and easier to manage. The logic for choosing between demo data and initial admin setup is clearly defined.

---

# How to work on the project
*   **Technology:** ASP.NET Core (.NET 9), Entity Framework Core, PostgreSQL.
*   **Architecture:** RESTful API following a Service Layer Pattern. Designed for multi-tenancy (data isolation per organization).
*   **Authentication/Authorization:** Uses ASP.NET Core Identity with JWT for authentication. Implement role-based authorization checks primarily within the Service layer (using `BaseService` helpers) and supplement with `[Authorize]` attributes on controllers where appropriate.
*   **Real-time:** Utilizes SignalR (`Hubs/OrderHub.cs`) for real-time communication with clients (Frontend, Companion Apps). Inject `IHubContext<OrderHub>` into services to broadcast messages.
*   **Database:** Use EF Core for data access. Apply schema changes via EF Core migrations (`dotnet ef migrations add`, `dotnet ef database update`). Ensure migrations are robust.
*   **Testing:** Write Integration Tests (`SagraFacile.NET.API.Tests.Integration`) for API endpoints and service logic. Manual testing by the user is also crucial for workflow validation. Aim for comprehensive integration test coverage.
*   **Memory:** Update this `ProjectMemory.md` file at the end of each session, summarizing accomplishments, key decisions, identified issues, and agreed-upon next steps. Reference `DataStructures.md` and `ApiRoutes.md` when discussing models or endpoints.
*   **Code Style:** Follow standard C# and ASP.NET Core conventions. Use dependency injection throughout.

---
# Session Summaries (Newest First)

## (2025-06-16) - Completed Backend Implementation for Charts & Analytics
**Context:** Completed Phase 9 (Backend) for the Charts & Analytics Dashboard feature as outlined in `docs/ChartsAnalyticsArchitecture.md` and `Roadmap.md`.
**Accomplishments:**
*   **DTOs Finalized:** All Data Transfer Objects for analytics are in place, including the new `OrderStatusTimelineEventDto.cs`. `SalesTrendDataDto.cs` and `AverageOrderValueTrendDto.cs` were updated to use nullable `DayId`.
*   **Service Layer (`IAnalyticsService` and `AnalyticsService.cs`):**
    *   The `IAnalyticsService.cs` interface was updated to include `GetOrderStatusTimelineAsync`.
    *   The `AnalyticsService.cs` was fully implemented with data querying and business logic for all defined analytics methods:
        *   `GetDashboardKPIsAsync`
        *   `GetSalesTrendAsync`
        *   `GetOrderStatusDistributionAsync`
        *   `GetTopMenuItemsAsync`
        *   `GetOrdersByHourAsync`
        *   `GetPaymentMethodDistributionAsync`
        *   `GetAverageOrderValueTrendAsync`
        *   `GetOrderStatusTimelineAsync` (Note: This implementation is simplified due to the `Order` model lacking individual status transition timestamps. It currently provides one event per order based on `OrderDateTime`.)
    *   Implemented a helper method `GetTargetDayAsync` for consistent operational day resolution.
    *   Corrected minor bugs related to nullable types and string checks.
*   **Report Generation:**
    *   `GenerateDailySummaryReportAsync` and `GenerateAreaPerformanceReportAsync` now produce basic text-based reports. PDF/Excel generation remains a future enhancement.
*   **Controller (`AnalyticsController.cs`):** Endpoints defined in the previous session now have corresponding service logic.
**Key Decisions & Notes:**
*   The `GetOrderStatusTimelineAsync` method's detail is limited by the current `Order` model. For a more granular timeline, the `Order` model would need to be augmented with specific timestamps for each status change, or a dedicated `OrderStatusHistory` table would be required.
*   Report generation is currently text-based. Integration of a PDF/Excel library is a separate future task if richer report formats are needed.
*   All queries consider relevant order statuses (e.g., excluding PreOrder, Pending, Cancelled for sales analytics).
**Next Steps:**
*   Proceed with Phase 9.3: Frontend foundation setup for charts and analytics.
*   User to review and test the implemented backend analytics endpoints.

## (2025-06-16) - Implemented Backend Foundation for Charts & Analytics
**Context:** Initiated Phase 9: Charts & Analytics Dashboard, focusing on the backend foundational structure as per `docs/ChartsAnalyticsArchitecture.md`.
**Accomplishments:**
*   **DTOs Created:** All necessary Data Transfer Objects for analytics were created in `SagraFacile.NET.API/DTOs/Analytics/`:
    *   `DashboardKPIsDto.cs`
    *   `SalesTrendDataDto.cs`
    *   `OrderStatusDistributionDto.cs`
    *   `TopMenuItemDto.cs`
    *   `OrdersByHourDto.cs`
    *   `PaymentMethodDistributionDto.cs`
    *   `AverageOrderValueTrendDto.cs`
*   **Service Layer:**
    *   Created `IAnalyticsService.cs` interface in `SagraFacile.NET.API/Services/` defining all required methods.
    *   Created a skeleton implementation `AnalyticsService.cs` in `SagraFacile.NET.API/Services/`, adhering to the existing `BaseService` pattern (injecting `ApplicationDbContext`, `IHttpContextAccessor`, `ILogger`) and including authorization checks.
*   **Controller:**
    *   Created `AnalyticsController.cs` in `SagraFacile.NET.API/Controllers/` with all API endpoints as specified in the architecture.
    *   Ensured controller patterns (error handling, response types) align with other controllers like `AreasController.cs`.
    *   Applied `[Authorize(Roles = "Admin,SuperAdmin")]` to protect all analytics endpoints.
*   **Dependency Injection:**
    *   Registered `IAnalyticsService` and `AnalyticsService` in `SagraFacile.NET.API/Program.cs`.
**Key Decisions:**
*   Organized analytics DTOs into a dedicated `Analytics` subfolder.
*   Ensured the new service and controller adhere to established project patterns for consistency, including how `BaseService` is utilized for user context and authorization.
*   Controller-level logging was initially added then removed from `AnalyticsController` to maintain consistency with other controllers where logging is primarily handled in the service layer.
**Next Steps:**
*   Implement the actual data querying and business logic within each method of `AnalyticsService.cs`.
*   Begin frontend implementation for Phase 9.

## (2025-06-15) - Fixed Printer Character Encoding for Euro & Accented Characters
**Context:** Euro symbol (€) and accented characters (à, è, ì, ò, ù, etc.) were printing incorrectly on thermal receipts and comandas. The printer manual indicated support for an IBM code page at index 14.
**Accomplishments:**
*   **Identified Correct Code Page:** User confirmed via printer manual that code page 14 (likely a variant of IBM CP858) was the correct one for their printer.
*   **`EscPosDocumentBuilder.cs` Update:**
    *   Modified the constructor and `InitializePrinter()` method to default to `(CodePage)14`. This ensures all documents (receipts, comandas, test prints) use this code page by default.
*   **`PrinterService.cs` Update:**
    *   Removed an explicit selection of `CodePage.PC858_EURO` (which corresponds to code page 19) from the receipt generation logic in `PrintOrderDocumentsAsync` and `ReprintOrderDocumentsAsync`. This allows the builder's new default (CP 14) to be used consistently.
    *   The `SendTestPrintAsync` method was initially updated to test CP14, and this explicit selection remains for clarity during test prints, though it's now redundant with the builder's default.
**Key Decisions:**
*   Standardized on Code Page 14 for all ESC/POS document generation based on printer manual and successful testing.
*   Made Code Page 14 the default in `EscPosDocumentBuilder` for system-wide consistency.
**Outcome:** Euro symbol and accented characters now print correctly on all thermal printer outputs.

## (2025-06-15) - Refactored Windows Printer Name Handling
**Context:** The `WindowsPrinterName` for `WindowsUsb` type printers was previously managed and stored in the backend database and sent to the Windows Printer Service companion app. This created redundancy as the companion app already manages the specific Windows printer to use via its local profiles (`SelectedPrinter` in `ProfileSettings`).
**Accomplishments:**
*   **Backend (`SagraFacile.NET.API`):**
    *   Removed `WindowsPrinterName` from the `Printer` entity/model (implicitly, by no longer using it in services).
    *   Removed `WindowsPrinterName` from `PrinterDto` and `PrinterUpsertDto`.
    *   `PrinterService.cs`:
        *   Modified `CreatePrinterAsync` and `UpdatePrinterAsync` to no longer handle `WindowsPrinterName`.
        *   `MapPrinterToDto` no longer maps `WindowsPrinterName`.
        *   `SendToPrinterAsync` for `WindowsUsb` printers no longer sends `WindowsPrinterName` as an argument in the SignalR `PrintJob` message to the companion app. The message now only contains `jobId` and `byte[] rawData`.
        *   `GetPrinterConfigAsync` (called by companion app) now only returns `PrintMode`. The companion app is responsible for knowing its own target printer name from its profile.
        *   `SendTestPrintAsync` no longer includes `WindowsPrinterName` in the generated test print slip.
    *   `IPrinterService.cs`: Updated `GetPrinterConfigAsync` signature to return `Task<PrintMode?>`.
    *   `PrintersController.cs`:
        *   Adjusted `GetPrinterConfig` endpoint to reflect the new return type from the service and now returns only `PrintMode` to the companion app.
        *   Adjusted `PostPrinter` to correctly map `PrintMode` to `PrinterDto` and no longer map `WindowsPrinterName`.
*   **Windows Printer Service (`SagraFacile.WindowsPrinterService`):**
    *   `SignalRService.cs`:
        *   `FetchPrinterConfigurationAsync`: Now retrieves only `PrintMode` from the backend. `_configuredWindowsPrinterName` is now set using the `_activeProfileSettings.SelectedPrinter` (the printer name selected in the companion app's profile).
        *   The SignalR `PrintJob` message handler registration (`_hubConnection.On`) was updated to expect only `jobId` and `rawData` from the backend.
        *   `HandlePrintJobAsync` method signature updated accordingly. It now uses `_configuredWindowsPrinterName` (derived from the active profile) to determine the target printer for `_rawPrinter.PrintRawAsync`.
        *   `PrintQueuedJobAsync` now uses `_configuredWindowsPrinterName` (or `_activeProfileSettings.SelectedPrinter`) instead of a printer name from the `PrintJobItem`.
    *   `Models/PrinterConfigDto.cs`: Removed `WindowsPrinterName` property, as it's no longer sent by the backend.
    *   `Models/PrintJobItem.cs`: Removed `TargetWindowsPrinterName` property and updated constructor. The printer to use is determined by the active profile in `SignalRService`.
**Key Decisions:**
*   Centralized the responsibility of knowing the specific Windows printer name to the Windows Printer Service companion app's profile system.
*   Simplified the backend by removing `WindowsPrinterName` from its storage and DTOs for `WindowsUsb` printers.
*   Reduced data transfer between backend and companion app.
**Outcome:** The companion app now solely relies on its local profile settings (`SelectedPrinter`) to determine which Windows printer to use for print jobs received via SignalR. The backend no longer manages or dictates this specific Windows printer name.

## (2025-06-15) - Resolved Docker Permissions for API Media Uploads
**Context:** The .NET API service, when running in Docker, encountered `System.UnauthorizedAccessException` when attempting to save uploaded ad media to `/app/wwwroot/media/promo`. This was due to the application user (`$APP_UID`) lacking write permissions to the target directory.
**Accomplishments:**
*   **Diagnosed Permission Issue:** Identified that the non-root user specified in the API's Dockerfile (`USER $APP_UID`) did not have write access to the `wwwroot/media` directory after it was copied during the image build.
*   **Dockerfile Modification (`SagraFacile.NET/SagraFacile.NET.API/Dockerfile`):**
    *   The `final` stage was updated to correctly prepare the media directory.
    *   Added `USER root` before creating the `/app/wwwroot/media/promo` directory and setting its ownership to `$APP_UID:$APP_UID` and permissions to `755`.
    *   Switched back to `USER $APP_UID` after these operations to ensure the application runs with the intended non-root user. This resolved a build failure where `mkdir` was denied permission when run as `$APP_UID`.
*   **Docker Compose Update (`docker-compose.yml`):**
    *   Removed the temporary `user: root` directive from the `api` service definition, as the permission issue is now correctly handled within the Docker image build process.
**Key Decisions:**
*   Prioritized running the API service as a non-root user for security.
*   Ensured that directory creation and permission settings within the Dockerfile are executed by a user with sufficient privileges (`root`) before switching to the less privileged application user.
**Outcome:** The .NET API can now successfully save uploaded ad media files within the Docker container without requiring the service to run as root. The Docker image builds successfully with the corrected permission setup.

## (2025-06-15) - Resolved Next.js Image Optimization Issue in Docker Environment
**Context:** The SagraFacile frontend was experiencing "400 Bad Request - The requested resource isn't a valid image" errors when using Next.js image optimization (`/_next/image`) in the Docker production environment. While direct image access worked, Next.js's internal image fetcher was receiving HTML responses instead of image content, indicating a circular routing issue through Caddy.
**Accomplishments:**
*   **Root Cause Identified:** The issue was that Next.js was trying to fetch images using the public domain URL (`https://app.sagrafacile.it/media/...`) from within the frontend container, creating a circular routing path: frontend → host-gateway → Caddy → frontend. This caused Caddy to return HTML responses instead of the actual image content.
*   **Environment-Aware Solution Implemented:** Created a comprehensive solution that maintains full Next.js image optimization while fixing the Docker networking issue:
    *   **Frontend Changes:** Updated `sagrafacile-webapp/next.config.ts` to include internal API service patterns and local development backend patterns. Created `sagrafacile-webapp/src/lib/imageUtils.ts` with environment-aware URL transformation functions.
    *   **URL Transformation Logic:** Implemented smart URL handling that uses internal Docker network URLs (`http://api:8080/media/...`) in production and backend API URLs in local development.
    *   **Image Component Updates:** Modified admin ads page and queue display components to use the new utility functions for proper image optimization.
*   **Docker Networking Fix:** The solution allows Next.js to fetch images directly from the API service within the Docker network, bypassing Caddy's reverse proxy for internal image requests and eliminating the circular routing issue.
**Key Decisions:**
*   Maintained full Next.js image optimization capabilities (resizing, format conversion, quality adjustment) rather than disabling optimization entirely.
*   Implemented environment-aware URL handling to ensure compatibility with both local development and Docker production environments.
*   Used internal Docker network communication for image fetching in production while preserving public URL access for direct requests.
**Outcome:** Next.js image optimization now works correctly in both local development and Docker production environments. Images load properly with full optimization benefits, and the 400 "invalid image" errors have been resolved.


## (2025-06-13) - Post-Deployment Fixes: Caddy API Routing & Windows Printer Service URL
**Context:** After successfully deploying the application on a home server using Docker Compose with Caddy and Let's Encrypt, two issues arose: API calls were resulting in 404 errors, and the Windows Printer Service was failing to connect to SignalR due to URL parsing.
**Accomplishments:**
*   **Caddyfile API Routing Fix:**
    *   **Issue:** API calls (e.g., to `/api/accounts/login`) were returning 404. This was because Caddy's `handle_path /api/*` directive was stripping the `/api/` prefix before proxying the request to the backend, while the .NET API routes expect the full `/api/...` path.
    *   **Solution:** Modified the `Caddyfile` to use `reverse_proxy /api/* api:8080` directly. This configuration correctly matches requests starting with `/api/` and proxies them to the `api` service (listening on port 8080) *without* stripping the `/api/` prefix. This resolved the 404 errors.
*   **Windows Printer Service URL Normalization:**
    *   **Issue:** The `SagraFacile.WindowsPrinterService` was logging an error "URL Base Hub 'app.sagrafacile.it/api' non valido" and failing to connect. The service's logic for constructing the full SignalR hub URL (`https://[base_url]/api/orderhub`) was not correctly handling cases where the base URL provided in settings might already contain a path (like `/api`) or lack a scheme.
    *   **Solution:** Updated `SagraFacile.NET/SagraFacile.WindowsPrinterService/Services/SignalRService.cs`. The `StartAsync` method now includes logic to normalize the `_hubHostAndPort` value read from settings. This normalization ensures:
        1.  A scheme (`https://` by default, or `http://` if the host is `localhost` or `127.0.0.1`) is present.
        2.  Any existing path components are removed from the stored base URL.
        For example, an input like `app.sagrafacile.it/api` or `app.sagrafacile.it` would be normalized to `https://app.sagrafacile.it`. The service then correctly appends `/api/orderhub` or `/api/printers/config/{guid}` to this clean base URL.
**Key Decisions:**
*   For Caddy, switched from `handle_path` to a direct `reverse_proxy` with path matching for API routes to ensure the backend receives the expected path.
*   Implemented robust URL normalization in the Windows Printer Service to make it more resilient to variations in how the server's base address is entered in its settings.
**Next Steps:**
*   User to test the Windows Printer Service with the updated URL normalization logic to confirm it connects successfully to the SignalR hub.

## (2025-06-13) - Implemented Multi-Instance Support for Windows Printer Service via Profiles
**Context:** Modified the `SagraFacile.WindowsPrinterService` to allow multiple instances to run on the same PC, each managing a different printer. This was achieved by introducing a profile-based configuration system.
**Accomplishments:**
*   **`Models/ProfileSettings.cs` Created:** Defined a class to hold settings for each printer profile (ProfileName, SelectedPrinter, HubHostAndPort, InstanceGuid).
*   **`ProfileSelectionForm.cs` & `ProfileSelectionForm.Designer.cs` Created:**
    *   A new form that appears on application startup.
    *   Lists existing profiles from `AppData\Local\SagraFacilePrinterService\profiles\*.json`.
    *   Allows users to load an existing profile, or create, edit, and delete profiles.
    *   Each profile is stored as a separate JSON file (e.g., `KitchenPrinter.json`).
*   **`InputDialogForm.cs` & `InputDialogForm.Designer.cs` Created:** A simple dialog to get user input, used for naming new profiles.
*   **`SettingsForm.cs` Modified:**
    *   Constructor now accepts a profile name and the profiles directory.
    *   Loads and saves settings to individual profile JSON files instead of a single global `settings.json`.
    *   Uses `InputDialogForm` to prompt for a name when creating a new profile.
    *   The static `GetSignalRConfig()` method was removed.
*   **`SignalRService.cs` Modified:**
    *   Now holds an `_activeProfileSettings` field.
    *   `StartAsync` is initiated after a profile is selected and its settings are passed via a new `SetActiveProfile()` method.
    *   Uses `HubHostAndPort` and `InstanceGuid` from the active profile.
    *   Logging and status messages now often include the profile name for clarity.
*   **`Program.cs` Modified:**
    *   Launches `ProfileSelectionForm` at startup.
    *   If a profile is selected, its settings are retrieved and stored in `Program.SelectedProfile`.
    *   These settings are then used to configure and start the `SignalRService` and `ApplicationLifetimeService`.
    *   The application exits if no profile is selected.
*   **`ApplicationLifetimeService.cs` Modified:**
    *   Accepts `ProfileSettings` via constructor injection.
    *   Displays the active profile name in the `PrintStationForm` title and tray icon tooltips/menu items.
    *   Correctly passes profile context when opening `SettingsForm`.
**Key Decisions:**
*   Adopted a profile-based system for multi-instance capability, where each instance is launched by selecting a distinct configuration profile.
*   Profile settings are stored in individual JSON files in a dedicated `profiles` subdirectory within the application's local data folder.
*   The application presents a profile selection dialog on startup, making it user-friendly to manage and launch different printer configurations.
**Next Steps:**
*   User to build and test the `SagraFacile.WindowsPrinterService`:
    *   Verify the `ProfileSelectionForm` appears on startup.
    *   Test creating new profiles, ensuring they are saved correctly.
    *   Test loading different profiles and confirming that each instance connects with its correct `InstanceGuid` and uses the correct settings.
    *   Test editing and deleting profiles.
    *   Confirm that UI elements (tray icon, PrintStationForm title) reflect the active profile.

## (2025-06-23) - Implemented Resilient Printing via Job Queue
**Context:** Rearchitected the printing system to be asynchronous and fault-tolerant, ensuring no print jobs are lost due to temporary printer or network failures. This involved implementing a persistent job queue in the database and a hybrid processing model for performance.
**Accomplishments:**
*   **Backend (.NET API):**
    *   **Database:** Created `PrintJob` entity and applied EF Core migrations (`AddPrintJobQueue`, `MakePrintJobAreaIdNullable`).
    *   **New Service (`PrintJobProcessor.cs`):** Implemented a `BackgroundService` to poll for pending jobs and process them.
    *   **"Fast Lane" Signaling:** Implemented an in-memory `SemaphoreSlim` to trigger the `PrintJobProcessor` instantly for high-priority jobs (e.g., receipts).
    *   **Refactored `PrinterService.cs`:** Changed `PrintOrderDocumentsAsync` and `ReprintOrderDocumentsAsync` to create and save `PrintJob` entities to the database instead of printing directly. The `SendToPrinterAsync` logic was adapted to be called by the `PrintJobProcessor`.
    *   **Refactored `OrderService.cs`:** Ensured it calls the new `PrinterService` methods correctly and handles the fast, asynchronous response.
    *   **`OrderHub.cs`:** Added a `ReportPrintJobStatus` method to receive status updates from the companion app.
*   **Windows Companion App (`SagraFacile.WindowsPrinterService`):**
    *   **`SignalRService.cs`:** Updated to receive `JobId` as `Guid` and to call the `ReportPrintJobStatus` hub method after a print attempt (success or failure), completing the confirmation loop.
    *   **`PrintJobItem.cs`:** Updated `JobId` to `Guid` to match backend.
**Key Decisions:**
*   Implemented a hybrid "Fast Lane" model to balance reliability (job queue) with performance (instant processing for critical jobs).
*   Ensured end-to-end confirmation for Windows USB printers via SignalR callbacks.
*   Made `AreaId` nullable in `PrintJob` to accommodate test prints not associated with a specific area.
**Outcome:** The printing system is now significantly more robust, with guaranteed delivery, automatic retries, and comprehensive status monitoring capabilities.
**Next Steps:**
*   User to test the new resilient printing system as per the provided instructions.
*   (Future) Implement Admin UI for monitoring print job statuses.

## (2025-06-23) - Implemented Admin UI for Print Job Monitoring
**Context:** Implemented the Admin UI for monitoring print jobs, providing visibility into the resilient printing system's operations. This builds upon the previously implemented backend job queue and processing.
**Accomplishments:**
*   **Backend (.NET API):**
    *   Created `PrintJobQueryParameters.cs`, `PrintJobDto.cs`, and `PaginatedResult.cs` DTOs for data transfer and pagination.
    *   Implemented `IPrintJobService.cs` and `PrintJobService.cs` to encapsulate business logic for fetching paginated and sortable print jobs, and for manually retrying failed jobs.
    *   Registered `IPrintJobService` and `PrintJobService` for dependency injection in `Program.cs`.
    *   Created `PrintJobsController.cs` with `GET /api/PrintJobs` (for paginated list) and `POST /api/PrintJobs/{jobId}/retry` (for manual retry) endpoints, secured with `Admin,SuperAdmin` roles.
*   **Frontend (Next.js WebApp):**
    *   Updated `sagrafacile-webapp/src/services/printerService.ts` to include `getPrintJobs` and `retryPrintJob` methods.
    *   Added `PrintJobStatus`, `PrintJobType`, `PrintJobDto`, `PrintJobQueryParameters`, and `PaginatedResult` TypeScript types to `sagrafacile-webapp/src/types/index.ts`.
    *   Created the new Admin UI page `sagrafacile-webapp/src/app/app/org/[orgId]/admin/print-jobs/page.tsx`. This page displays a table of print jobs with columns for ID, JobType, Status, CreatedAt, LastAttemptAt, RetryCount, ErrorMessage, OrderId, and PrinterName.
    *   Implemented client-side pagination and sorting for the print jobs table.
    *   Added a "Retry Manually" action for failed print jobs, which triggers the backend retry endpoint.
    *   Ensured date formatting uses vanilla JavaScript `Date` methods for consistency.
    *   Added a link to "Monitoraggio Stampe" in `sagrafacile-webapp/src/components/admin/AdminNavigation.tsx`.
    *   Added a new card for "Monitoraggio Stampe" to the main Admin Dashboard page (`sagrafacile-webapp/src/app/app/org/[orgId]/admin/page.tsx`).
**Key Decisions:**
*   Implemented server-side pagination and sorting for print jobs to optimize performance for large datasets.
*   Provided a manual retry mechanism for failed jobs, complementing the automatic retry logic in the `PrintJobProcessor`.
*   Used vanilla JavaScript for date formatting in the frontend as per user preference.
*   Integrated the new page into the existing admin navigation and dashboard for easy access.
**Outcome:** The system now has a functional Admin UI for monitoring the status of print jobs, allowing administrators to track print operations and manually intervene if necessary.
**Next Steps:**
*   (Future Phase 2) Implement real-time alerts and notifications for print job failures.

## (2025-06-23) - Refactored Orders Page with Reusable Paginated Table
**Context:** Refactored the admin "Storico Ordini" page to use a new reusable, paginated table component, enhancing performance and code reuse.
**Accomplishments:**
*   **Backend (.NET API):**
    *   Implemented server-side pagination and sorting for the `GET /api/Orders` endpoint.
    *   Created `OrderQueryParameters.cs` DTO to handle pagination, sorting, and filtering (by `AreaId`, `DayId`, `OrganizationId`).
    *   Updated `IOrderService.cs` and `OrderService.cs` to replace the old `GetOrdersAsync` with a new method that accepts `OrderQueryParameters` and returns a `PaginatedResult<OrderDto>`.
    *   Installed `System.Linq.Dynamic.Core` to enable dynamic sorting based on string property names.
    *   Updated `OrdersController.cs` to use the new service method and DTO.
*   **Frontend (Next.js WebApp):**
    *   Created a generic, reusable `PaginatedTable.tsx` component in `src/components/common/`. This component handles table rendering, sorting, pagination controls, and a page size selector. It also persists page size settings to `localStorage`.
    *   Refactored `sagrafacile-webapp/src/app/app/org/[orgId]/admin/print-jobs/page.tsx` to use the new `PaginatedTable` component, simplifying its code significantly.
    *   Refactored `sagrafacile-webapp/src/app/app/org/[orgId]/admin/orders/page.tsx`:
        *   Replaced the old static `OrderTable.tsx` with the new `PaginatedTable.tsx`.
        *   Integrated the `AdminAreaSelector.tsx` component for area filtering.
        *   Added `orderService.ts` to fetch paginated order data.
        *   Updated `types/index.ts` with `OrderQueryParameters`.
    *   Deleted the now-redundant `OrderTable.tsx` component.
**Key Decisions:**
*   Abstracted table logic into a reusable `PaginatedTable` component to be used across different admin pages.
*   Implemented server-side pagination for the Orders API to handle potentially large datasets efficiently.
*   Leveraged `localStorage` in the `PaginatedTable` component to provide a better user experience by remembering page size preferences.
**Outcome:** The Orders and Print Jobs admin pages are now more performant and maintainable. The new `PaginatedTable` component can be easily reused for other data tables in the application.

## (Next Session) - Planned Work
*   **Summary:** Current session paused USB thermal printer debugging due to `SagraFacile.WindowsPrinterService` companion app registration issues. Next steps: Enhance companion app UI/UX for connection status and settings, improve logging. Then, resume USB thermal printer debugging, focusing on correct registration with `OrderHub` and print job dispatch/receipt verification.


---
# Historical Sessions (Condensed)

## Stock Management (Backend - 2025-06-04)
*   **Summary:** Implemented backend for Stock Management (`Scorta` property on `MenuItem`, related DTO updates, `MenuItemService` enhancements for stock operations like `UpdateStockAsync`, `ResetStockAsync`, `ResetAllStockForAreaAsync`, and `OrderService` updates for transactional stock checks/decrements during order creation/confirmation and SignalR broadcasts for stock changes). New `MenuItemsController` endpoints were added for stock management. An EF Core migration (`AddScortaToMenuItem`) was created.
*   **Key Decisions:** `Scorta = null` signifies unlimited quantity. Stock checks and decrements are transactional. SignalR broadcasts `StockUpdateBroadcastDto` for real-time updates.
*   **Outcome:** Frontend implementation for Admin UI and Cashier UI followed.

## DisplayOrderNumber Frontend Fixes & KDS Check (Note - 2025-06-04)
*   **Summary:** Noted frontend fixes for `DisplayOrderNumber` and a verification task for the backend to ensure `KdsOrderDto` correctly populates `displayOrderNumber` for KDS stations.
*   **Outcome:** User to test frontend; backend KDS DTO verification pending.

## Display Order Number (Backend - 2025-06-03)
*   **Summary:** Implemented the backend for the "Display Order Number" feature. This included adding a `DisplayOrderNumber` property to the `Order` model, creating the `AreaDayOrderSequence` entity to manage unique daily sequences per area, updating `ApplicationDbContext`, and creating the `AddDisplayOrderNumber` EF Core migration. `OrderService` was enhanced to generate these numbers during order creation/confirmation, and DTOs (`OrderDto`, `OrderStatusBroadcastDto`) were updated. `PrinterService` was modified to use the new display number. The internal `Order.Id` was changed to use GUIDs for new orders.
*   **Key Decisions:** Internal `Order.Id` remains PK (now GUID). `DisplayOrderNumber` generated upon order activation (create/confirm pre-order), prefixed by `Area.Slug`. QR codes on receipts continue to use internal `Order.Id`.
*   **Outcome:** Frontend UI updates and testing followed in subsequent sessions.

## Automatic Token Refresh (Backend - 2025-05-29)
*   **Summary:** Implemented a JWT refresh token strategy. Created `TokenResponseDto` and `RefreshTokenRequestDto`. Updated the `User` model with `RefreshToken` and `RefreshTokenExpiryTime` (migration `AddUserRefreshTokens`). `AccountService` was enhanced to generate, store, and validate refresh tokens, implementing token rotation. `LoginUserAsync` now returns both tokens, and `RefreshTokenAsync` handles renewal. A new public endpoint `POST /api/accounts/refresh-token` was added to `AccountsController`. Token lifetimes were made configurable.
*   **Key Decisions:** Standard JWT refresh token flow with token rotation. Short-lived access tokens (e.g., 15 mins), longer-lived refresh tokens (e.g., 7 days) stored in the database.
*   **Outcome:** Frontend integration to handle token storage, refresh calls on 401s, and session management was completed.

## Public Order Pickup Display (Backend - 2025-05-29)
*   **Summary:** Implemented backend components for the Public Order Pickup Display. This involved creating `OrderStatusBroadcastDto` for SignalR. `OrderService.SendOrderStatusUpdateAsync` was refactored to broadcast this DTO. A new method `OrderService.GetOrdersByStatusAsync(areaId, status)` was added to fetch orders for the display's initial load (filtered by current open `DayId`), with enhanced logging for debugging. A new public endpoint `GET /api/public/areas/{areaId}/orders/ready-for-pickup` was added to `PublicController.cs`. The `OrderHub` utilizes existing group mechanisms for client subscriptions. The "Planned Public Order Pickup Display" session's items were incorporated into this implementation.
*   **Outcome:** Frontend implementation for the public display and staff confirmation pages followed. Debugging of `GetOrdersByStatusAsync` related to `DayId` filtering was noted as an ongoing concern based on frontend testing.

## Customer Queue System (Backend - "Previous Date" prior to 2025-05-29)
*   **Summary:** Completed the backend implementation for the Customer Queue System. This included the `AreaQueueState` entity, `Area.EnableQueueSystem` flag, and EF Core migration `AddQueueManagement`. DTOs (`CalledNumberDto`, `CalledNumberBroadcastDto`, `QueueStateDto`) and `ServiceResult` were created. `IQueueService` and `QueueService.cs` were implemented with logic for managing queue state, calling numbers, and admin operations, including SignalR broadcasts (`QueueNumberCalled`, `QueueReset`, `QueueStateUpdated`). A `QueueController.cs` was added with API endpoints and role-based authorization.
*   **Key Decisions:** Used optimistic concurrency for state updates. `CallSpecificAsync` updates 'last called' but not `NextSequentialNumber`. Admin actions require `Admin`/`SuperAdmin`, Cashier actions allow `Cashier` role.
*   **Outcome:** Frontend UI implementation for Cashier and Public Display followed. User was tasked to apply the database migration.

## Customer Queue System - Initial Models (Various Dates)
*   Implemented `AreaQueueState` entity and added `EnableQueueSystem` flag to `Area`.
*   Configured database context and relationships for the queue system.

## Configurable Printing Architecture (Various Dates)
*   **Admin-Selected Printer for Reprints:** Modified `ReprintRequestDto` and `PrinterService` to allow optional admin override for reprint printer destination.
*   **Order Service Integration:** Integrated `IPrinterService` into `OrderService`, refined logic for triggering receipt and comanda prints based on workflow states and configuration flags (`PrintComandasAtThisStation`, `PrintComandasAtCashier`), preventing duplicate comanda prints.
*   **Reprint Functionality & Item Notes:** Implemented backend reprint API (`/api/orders/{orderId}/reprint`) with consolidated comandas. Ensured `OrderItem.Note` is included on receipts and comandas. Updated pre-order confirmation DTO/logic.
*   **ESC/POS Generation:** Implemented detailed ESC/POS generation using `EscPosDocumentBuilder` in `PrinterService` for receipts, comandas (refactored with helpers), and test prints, replacing dummy data.
*   **SignalR & Print Dispatch:** Enhanced `OrderHub` to manage Windows printer client connections (`RegisterPrinterClient`, `_printerConnections`). Implemented `PrinterService` logic to determine target printers based on rules (station, area, category) and dispatch jobs via TCP/IP (Network) or SignalR (WindowsUsb).
*   **Printer Configuration Backend (Phase 1):** Established initial database models (`Printer`, `PrinterCategoryAssignment`, `PrinterType`), DTOs, basic CRUD services (`PrinterService`), and API endpoints (`PrintersController`) for managing printers.

## Windows Printer Service (2024-07-26)
*   **Refactored to SignalR:** Replaced WebSocket with SignalR (`SignalRService`) for backend communication. Simplified configuration (removed registration token, simplified Hub URL). Utilized raw Windows printing via P/Invoke (`RawPrinterHelperService`). Updated settings UI and documentation.
*   **User Tasks Defined:** Specified necessary project file updates and UI changes for the Windows Printer Service refactoring.
*   **Backend Alignment:** Confirmed `OrderHub` and `PrinterService` align with the simplified Windows service registration and `PrintJob` message format.
